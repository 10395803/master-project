% getMappedLinearPoisson2dFEP1System Build stiffness matrix and right-hand 
% side for the linear system yielded by linear Finite Elements (FE-P1) method
% applied to the linear two-dimensional Poisson equation mapped to the
% reference, unit square.
%
% [A, rhs] = getMappedLinearPoisson2dFEP1System(geometry, domain, mesh, ...
%    K, f, BCs_t, BCs_v, BCe_t, BCe_v, BCn_t, BCn_v, BCw_t, BCw_v)
%
% \param geometry   string reporting the shape of the domain:
%                   - 'quad': quadrilateral domain
% \param domain     struct storing some information about the domain; this
%                   is generated by buildMesh2d
% \param mesh_r     computational mesh; this should be a mesh2d object
% \param K          handle to a function evaluating the viscosity matrix in 
%                   a generic two-dimensional point, passed as a two-elements 
%                   array; see MatrixFunctions folder
% \param f          handle to a function evaluating the forcing term in a
%                   generic two-dimensional point, passed as a two-elements
%                   array ; see ScalarFunctions folder
% \param BCs_t      type of boundary condition onto the South edge:
%                   - 'D': Dirichlet
%                   - 'N': Neumann
% \param BCs_v      handle function to South boundary condition
% \param BCe_t      type of boundary condition onto the East edge:
%                   - 'D': Dirichlet
%                   - 'N': Neumann
% \param BCe_v      handle function to East boundary condition
% \param BCn_t      type of boundary condition onto the North edge:
%                   - 'D': Dirichlet
%                   - 'N': Neumann
% \param BCn_v      handle function to North boundary condition
% \param BCw_t      type of boundary condition onto the West edge:
%                   - 'D': Dirichlet
%                   - 'N': Neumann
% \param BCw_v      handle function to West boundary condition

function [stif, rhs] = getMappedLinearPoisson2dFEP1System(geometry, domain, mesh_r, ...
    K, f, BCs_t, BCs_v, BCe_t, BCe_v, BCn_t, BCn_v, BCw_t, BCw_v)    
    % Shortcuts
    nodes = mesh_r.nodes;  elems = mesh_r.elems;
    Nn = mesh_r.getNumNodes();  Ne = mesh_r.getNumElems();
    
    % Store gradients of basis functions on reference triangle
    gr1 = [-1 -1]';  gr2 = [1 0]';  gr3 = [0 1]';
    
    % Quadrature nodes and weights
    % A three- or four-points Gauss quadrature rule is used, but it may easily
    % changed by accordingly changed the nodes and the weights
    %q1 = [1/6 1/6]';  q2 = [2/3 1/6]';  q3 = [1/6 2/3]';
    %w1 = 1/3;  w2 = 1/3;  w3 = 1/3;
    p1 = [1/3 1/3]';  p2 = [1/5 1/5]';  p3 = [3/5 1/5]';  p4 = [1/5 3/5]';
    w1 = -27/48;  w2 = 25/48;  w3 = 25/48;  w4 = 25/48;
    
    % Allocate memory for the stiffness matrix and right-hand side
    stif = spalloc(Nn,Nn,round(0.1*Nn*Nn));  rhs = zeros(Nn,1);
    
    % For the sake of efficiency, the implementation is tailored on each
    % geometry the solver can handle
    if strcmp(geometry,'quad')
        % Shortcuts
        A = domain.A;  B = domain.B;  C = domain.C;  D = domain.D;
        
        % Construct matrix characterizing map from reference to physical domain
        M = [B-A D-A A-B+C-D A];  
                
        % Go through all elements of the mesh
        for n = 1:Ne
            % Extract the vertices of the triangle
            ia = elems(1,n);   ib = elems(2,n);   ic = elems(3,n);
            va = nodes(:,ia);  vb = nodes(:,ib);  vc = nodes(:,ic);

            % Compute Jacobian of the map from reference to current
            % triangle, its inverse and its determinant
            Jphi  = [vb(1)-va(1) vc(1)-va(1); vb(2)-va(2) vc(2)-va(2)];
            dJphi = abs(Jphi(1,1)*Jphi(2,2) - Jphi(1,2)*Jphi(2,1));
            iJphi = [Jphi(2,2) -Jphi(1,2); -Jphi(2,1) Jphi(1,1)];
            
            % Map quadrature nodes onto the physical (i.e. original) domain
            q1 = Jphi*p1 + va;  q2 = Jphi*p2 + va;
            q3 = Jphi*p3 + va;  q4 = Jphi*p4 + va;
            r1 = M*[q1; q1(1)*q1(2); 1] + A;  r2 = M*[q2; q2(1)*q2(2); 1] + A;  
            r3 = M*[q3; q3(1)*q3(2); 1] + A;  r4 = M*[q4; q4(1)*q4(2); 1] + A; 
            
            % Evaluate determinant and inverse of the Jacobian of the map 
            % from reference to physical domain at the quadrature nodes
            dJpsi1 = dJpsi_quad(q1,A,B,C,D);  iJpsi1 = iJpsi_quad(q1,A,B,C,D);
            dJpsi2 = dJpsi_quad(q2,A,B,C,D);  iJpsi2 = iJpsi_quad(q2,A,B,C,D);
            dJpsi3 = dJpsi_quad(q3,A,B,C,D);  iJpsi3 = iJpsi_quad(q3,A,B,C,D);
            dJpsi4 = dJpsi_quad(q4,A,B,C,D);  iJpsi4 = iJpsi_quad(q4,A,B,C,D);
            
            % Compute entries of the stiffness matrix onto the reference triangle
            aux = iJphi * (w1 * iJpsi1 * K(r1)' * iJpsi1' / dJpsi1 + ...
                  w2 * iJpsi2 * K(r2)' * iJpsi2' / dJpsi2 + ...
                  w3 * iJpsi3 * K(r3)' * iJpsi3' / dJpsi3 + ...
                  w4 * iJpsi4 * K(r4)' * iJpsi4' / dJpsi4) * iJphi' / dJphi;   
            A11 = gr1'* aux * gr1;  A12 = gr1'* aux * gr2;
            A13 = gr1'* aux * gr3;  A22 = gr2'* aux * gr2;
            A23 = gr2'* aux * gr3;  A33 = gr3'* aux * gr3;

            % Assemble stiffness matrix
            stif(ia,ia) = stif(ia,ia) + A11;  
            stif(ia,ib) = stif(ia,ib) + A12;  stif(ib,ia) = stif(ib,ia) + A12;
            stif(ia,ic) = stif(ia,ic) + A13;  stif(ic,ia) = stif(ic,ia) + A13;
            stif(ib,ib) = stif(ib,ib) + A22;
            stif(ib,ic) = stif(ib,ic) + A23;  stif(ic,ib) = stif(ic,ib) + A23;
            stif(ic,ic) = stif(ic,ic) + A33;

            % Compute entries of the right-hand side onto the reference triangle
            b1 = (w1 * f(r1) * (1-r1(1)-r1(2)) * dJpsi1 + ...
                w2 * f(r2) * (1-r2(1)-r2(2)) * dJpsi2 + ...
                w3 * f(r3) * (1-r3(1)-r3(2)) * dJpsi3 + ...
                w4 * f(r4) * (1-r4(1)-r4(2)) * dJpsi4) * dJphi;
            b2 = (w1 * f(r1) * r1(1) * dJpsi1 + w2 * f(r2) * r2(1) * dJpsi2 + ...
                w3 * f(r3) * r3(1) * dJpsi3 + w4 * f(r4) * r4(1) * dJpsi4) * dJphi;
            b3 = (w1 * f(r1) * r1(2) * dJpsi1 + w2 * f(r2) * r2(2) * dJpsi2 + ...
                w3 * f(r3) * r3(2) * dJpsi3 + w4 * f(r4) * r4(2) * dJpsi4) * dJphi;
            
            % Assemble right-hand side
            rhs(ia) = rhs(ia) + b1;  rhs(ib) = rhs(ib) + b2;  rhs(ic) = rhs(ic) + b3;
        end
        
        % Apply boundary conditions
        h = 0.5*(mesh_r.hmin+mesh_r.hmax);  TOL = 1e-15;
        for i = 1:Nn
            if (-TOL < nodes(2,i) && nodes(2,i) < TOL)        % South edge
                stif(i,:) = 0;  stif(i,i) = h;
                rhs(i) = h * BCs_v(M*[nodes(:,i); nodes(1,i)*nodes(2,i); 1] + A);
            elseif (1-TOL < nodes(2,i) && nodes(2,i) < 1+TOL) % North edge
                stif(i,:) = 0;  stif(i,i) = h;
                rhs(i) = h * BCn_v(M*[nodes(:,i); nodes(1,i)*nodes(2,i); 1] + A);
            elseif (-TOL < nodes(1,i) && nodes(1,i) < TOL)    % West edge
                stif(i,:) = 0;  stif(i,i) = h;
                rhs(i) = h * BCw_v(M*[nodes(:,i); nodes(1,i)*nodes(2,i); 1] + A);
            elseif (1-TOL < nodes(1,i) && nodes(1,i) < 1+TOL) % East edge
                stif(i,:) = 0;  stif(i,i) = h;
                rhs(i) = h * BCe_v(M*[nodes(:,i); nodes(1,i)*nodes(2,i); 1] + A);
            end
        end
    end
end

function d = dJpsi_quad(x, A, B, C, D)
    d = abs((B(1)-A(1))*(D(2)-A(2)) - (D(1)-A(1))*(B(2)-A(2)) + ...
        ((B(1)-A(1))*(C(2)-D(2)) - (C(1)-D(1))*(B(2)-A(2)))*x(1) + ...
        ((C(1)-B(1))*(D(2)-A(2)) - (D(1)-A(1))*(C(2)-A(2)))*x(2));
end

function J = iJpsi_quad(x, A, B, C, D)
    J = [(A(2)-B(2)+C(2)-D(2))*x(1) + (D(2)-A(2)), ...
        -(A(1)-B(1)+C(1)-D(1))*x(1) - (D(1)-A(1)); ...
        -(A(2)-B(2)+C(2)-D(2))*x(2) - (B(2)-A(2)), ...
        (A(1)-B(1)+C(1)-D(1))*x(2) + (B(1)-A(1))];
end